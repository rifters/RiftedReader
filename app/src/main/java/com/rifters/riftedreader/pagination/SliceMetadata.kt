package com.rifters.riftedreader.pagination

import com.rifters.riftedreader.domain.pagination.ChapterIndex
import com.rifters.riftedreader.domain.pagination.WindowIndex

/**
 * Metadata about a single page slice within a window.
 * 
 * Each slice represents one viewport-sized page that was created by the
 * node-walking algorithm in flex_paginator.js. Slices are created offscreen
 * during window assembly and cached for instant display.
 * 
 * @property page Page index within the window (0-indexed)
 * @property chapter Chapter index within the book (global)
 * @property startChar Starting character offset within the chapter
 * @property endChar Ending character offset within the chapter
 * @property heightPx Measured height of this page in pixels
 */
data class PageSlice(
    val page: Int,
    val chapter: ChapterIndex,
    val startChar: Int,
    val endChar: Int,
    val heightPx: Int
)

/**
 * Complete metadata for all slices in a window.
 * 
 * This data is generated by flex_paginator.js after the node-walking
 * slicing algorithm completes. It's cached with the WindowData to enable
 * zero-latency navigation and precise bookmark restoration.
 * 
 * @property windowIndex The window this metadata belongs to
 * @property totalPages Total number of pages in this window
 * @property slices List of individual page slices with character offsets
 */
data class SliceMetadata(
    val windowIndex: WindowIndex,
    val totalPages: Int,
    val slices: List<PageSlice>
) {
    /**
     * Get the slice for a specific page index.
     * 
     * @param pageIndex The page index to look up (0-indexed)
     * @return The PageSlice for that page, or null if out of range
     */
    fun getSlice(pageIndex: Int): PageSlice? {
        return slices.getOrNull(pageIndex)
    }
    
    /**
     * Find the page index containing a specific character offset in a chapter.
     * 
     * This is used for bookmark restoration - given a chapter and character
     * offset, find which page to navigate to.
     * 
     * @param chapterIndex The chapter to search in
     * @param charOffset The character offset within that chapter
     * @return The page index containing that position, or null if not found
     */
    fun findPageByCharOffset(chapterIndex: ChapterIndex, charOffset: Int): Int? {
        return slices.indexOfFirst { slice ->
            slice.chapter == chapterIndex &&
            charOffset >= slice.startChar &&
            charOffset < slice.endChar
        }.takeIf { it >= 0 }
    }
    
    /**
     * Get all slices for a specific chapter.
     * 
     * @param chapterIndex The chapter to filter by
     * @return List of slices belonging to that chapter
     */
    fun getSlicesForChapter(chapterIndex: ChapterIndex): List<PageSlice> {
        return slices.filter { it.chapter == chapterIndex }
    }
    
    /**
     * Check if this metadata is valid and ready to use.
     * 
     * @return true if the metadata has pages and slices match totalPages
     */
    fun isValid(): Boolean {
        return totalPages > 0 && slices.size == totalPages
    }
}
